// Code generated by hertz generator.

package second

import (
	"api.service/biz/model/api/douyin/core"
	"api.service/biz/rpc"
	basics "basics.rpc/kitex_gen/douyin/core"
	"context"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	society "society.rpc/kitex_gen/douyin/extra/second"
	"strings"

	second "api.service/biz/model/api/douyin/extra/second"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// RelationAction .
// @router /douyin/relation/action [POST]
func RelationAction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req second.DouyinRelationActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	toUserId := req.ToUserId
	actionType := req.ActionType
	resp := new(second.DouyinRelationActionResponse)

	myId := c.GetInt64("myId")

	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: myId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: toUserId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	if actionType == 1 {
		if toUserId == 0 || myId == 0 {
			hlog.Infof("toUserId or myId is null")
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "toUserId or myId is null"))
			return
		}
		//关注
		_, err := rpc.SocietyService.ConcernAction(ctx, &society.ConcernActionRequest{FromUserId: myId, ToUserId: toUserId})
		if err != nil {
			hlog.Infof("SocietyService failed err:%v", err)
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
			return
		}
	} else if actionType == 2 {
		if toUserId == 0 || myId == 0 {
			hlog.Infof("toUserId or myId is null")
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "toUserId or myId is null"))
			return
		}
		//取消关注
		_, err := rpc.SocietyService.CancelConcernAction(ctx, &society.CancelConcernActionRequest{FromUserId: myId, ToUserId: toUserId})
		if err != nil {
			hlog.Infof("SocietyService failed err:%v", err)
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
			return
		}
	} else {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "action type valid"))
		return
	}
	resp.StatusCode = 0
	resp.StatusMsg = new(string)
	*resp.StatusMsg = "success"
	c.Set("actionType", actionType)
	c.Set("toUserId", toUserId)
	c.JSON(consts.StatusOK, resp)
}

// RelationFollowList .
// @router /douyin/relation/follow/list [GET]
func RelationFollowList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req second.DouyinRelationFollowListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	//myId := c.GetInt64("myId")
	userId := req.UserId
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: userId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	resp := new(second.DouyinRelationFollowListResponse)
	if userId == 0 {
		hlog.Infof("userId is null")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "userId is null"))
		return
	}
	followListResponse, err := rpc.SocietyService.FollowList(ctx, &society.FollowListRequest{UserId: userId})
	if err != nil {
		hlog.Infof("SocietyService failed err:%v", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	users := followListResponse.UserList
	userList := make([]*second.User, 0, len(users))
	for _, user := range users {
		userList = append(userList, &second.User{
			Id:            user.Id,
			Name:          user.Name,
			FollowCount:   &user.FollowCount,
			FollowerCount: &user.FollowerCount,
			IsFollow:      user.IsFollow,
		})
	}
	resp.StatusCode = 0
	resp.StatusMsg = new(string)
	*resp.StatusMsg = "success"
	resp.UserList = userList

	c.JSON(consts.StatusOK, resp)
}

// RelationFollowerList .
// @router /douyin/relation/follower/list [GET]
func RelationFollowerList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req second.DouyinRelationFollowerListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	resp := new(second.DouyinRelationFollowerListResponse)

	userId := req.UserId
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: userId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	if userId == 0 {
		hlog.Infof("userId is null")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "userId is null"))
		return
	}
	var followerListResponse *society.FollowerListResponse
	if req.PageNo == nil || req.PageSize == nil {
		followerListResponse, err = rpc.SocietyService.FollowerList(ctx, &society.FollowerListRequest{UserId: userId})
	} else {
		followerListResponse, err = rpc.SocietyService.FollowerList(ctx, &society.FollowerListRequest{UserId: userId, PageNo: *req.PageNo, PageSize: *req.PageSize})
	}
	if err != nil {
		hlog.Infof("SocietyService failed err:%v", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	users := followerListResponse.UserList
	userList := make([]*second.User, 0, len(users))
	for _, user := range users {
		userList = append(userList, &second.User{
			Id:            user.Id,
			Name:          user.Name,
			FollowCount:   &user.FollowCount,
			FollowerCount: &user.FollowerCount,
			IsFollow:      user.IsFollow,
		})
	}
	resp.StatusCode = 0
	resp.StatusMsg = new(string)
	*resp.StatusMsg = "success"
	resp.UserList = userList
	c.JSON(consts.StatusOK, resp)
}

// RelationFriendList .
// @router /douyin/relation/friend/list [GET]
func RelationFriendList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req second.DouyinRelationFriendListRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	resp := new(second.DouyinRelationFriendListResponse)

	userId := req.UserId
	myId := c.GetInt64("myId")
	if myId != userId {
		hlog.Infof("auth failed")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "auth failed."))
		return
	}
	if userId == 0 {
		hlog.Infof("userId is null")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "userId is null"))
		return
	}
	friendListResponse, err := rpc.SocietyService.FriendList(ctx, &society.FriendListRequest{UserId: userId})
	if err != nil {
		hlog.Infof("SocietyService failed err:%v", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	users := friendListResponse.UserList
	userList := make([]*second.User, 0, len(users))
	for _, user := range users {
		userList = append(userList, &second.User{
			Id:            user.Id,
			Name:          user.Name,
			FollowCount:   &user.FollowCount,
			FollowerCount: &user.FollowerCount,
			IsFollow:      user.IsFollow,
		})
	}
	resp.StatusCode = 0
	resp.StatusMsg = new(string)
	*resp.StatusMsg = "success"
	resp.UserList = userList
	c.JSON(consts.StatusOK, resp)
}

// MessageChat .
// @router /douyin/message/chat/ [GET]
func MessageChat(ctx context.Context, c *app.RequestContext) {
	var err error
	var req second.DouyinMessageChatRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}

	resp := new(second.DouyinMessageChatResponse)

	toUserId := req.ToUserId
	myId := c.GetInt64("myId")
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: myId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: toUserId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	if myId == toUserId {
		hlog.Infof("fromUserId = toUserId error")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "fromUserId = toUserId error"))
		return
	}
	if myId == 0 || toUserId == 0 {
		hlog.Infof("myId or toUserId is null")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "myId or toUserId is null"))
		return
	}
	_, err = rpc.SocietyService.IsFriend(ctx, &society.IsFriendRequest{MyUserId: myId, FriendUserId: toUserId})
	if err != nil {
		hlog.Infof("SocietyService failed err:%v", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	var messageChatResponse *society.MessageChatResponse
	if req.StartTime == nil || req.EndTime == nil {
		messageChatResponse, err = rpc.SocietyService.MessageChat(ctx, &society.MessageChatRequest{MyUserId: myId, FriendUserId: toUserId})
		if err != nil {
			hlog.Infof("SocietyService failed err:%v", err)
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
			return
		}
	} else {
		messageChatResponse, err = rpc.SocietyService.MessageChat(ctx, &society.MessageChatRequest{MyUserId: myId, FriendUserId: toUserId, StartTime: *req.StartTime, EndTime: *req.EndTime})
		if err != nil {
			hlog.Infof("SocietyService failed err:%v", err)
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
			return
		}
	}
	messageList := messageChatResponse.MessageList
	messages := make([]*second.Message, 0, len(messageList))
	for _, message := range messageList {
		messages = append(messages, &second.Message{
			Id:               message.Id,
			FromUserId:       message.FromUserId,
			ToUserId:         message.ToUserId,
			Content:          message.Content,
			CreateTime:       message.CreateTime,
			CreateTimeFormat: message.CreateTimeFormat,
		})
	}
	resp.StatusCode = 0
	resp.StatusMsg = new(string)
	*resp.StatusMsg = "success"
	resp.MessageList = messages
	c.JSON(consts.StatusOK, resp)
}

// MessageAction .
// @router /douyin/message/action/ [POST]
func MessageAction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req second.DouyinMessageActionRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}

	resp := new(second.DouyinMessageActionResponse)

	toUserId := req.ToUserId
	actionType := req.ActionType
	content := req.Content
	myId := c.GetInt64("myId")
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: toUserId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	_, err = rpc.BasicsService.GetUserInfoById(ctx, &basics.GetUserRequest{UserId: myId})
	if err != nil {
		hlog.Infof("BasicsService failed err:%v\n", err)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
		return
	}
	if myId == toUserId {
		hlog.Infof("fromUserId = toUserId error")
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "fromUserId = toUserId error"))
		return
	}

	if actionType == 1 {
		if myId == 0 || toUserId == 0 || content == "" {
			hlog.Infof("myId or toUserId or content is null")
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "myId or toUserId or content is null"))
			return
		}
		//发送消息
		_, err := rpc.SocietyService.MessageSend(ctx, &society.MessageSendRequest{MyUserId: myId, FriendUserId: toUserId, Content: content})
		if err != nil {
			hlog.Infof("SocietyService failed err:%v", err)
			c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, err.Error()))
			return
		}
		resp.StatusCode = 0
		resp.StatusMsg = new(string)
		*resp.StatusMsg = "success"
		c.JSON(consts.StatusOK, resp)
		return
	} else {
		hlog.Infof("action type valid actionType:%d", actionType)
		c.JSON(consts.StatusBadRequest, returnErrorResponse(consts.StatusBadRequest, "action type valid"))
		return
	}
}

func returnErrorResponse(code int32, msg string) core.CommonResponse {
	if strings.Contains(msg, "remote or network error[remote]: biz error: ") {
		msg = strings.Replace(msg, "remote or network error[remote]: biz error: ", "", 1)
	}
	return core.CommonResponse{
		StatusCode: code,
		StatusMsg:  msg,
	}
}
